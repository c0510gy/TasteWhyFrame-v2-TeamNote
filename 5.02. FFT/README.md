# Fast Fourier Transform (빠른 푸리에 변환)

두 수열 a, b의 Discrete Convolution(이산 합성곱) c를 빠르게 구하기 위한 알고리즘.

[FFT 이해하는데 추천하는 블로그](https://m.blog.naver.com/PostView.nhn?blogId=wjdalsdl1016&logNo=221109321310&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)

## 합성곱의 정의

$c_k=\sum_{i=0}^{k}a_i\cdot b_{k-i}$

##### 예시
$c[0]=c[0]*b[0]$

$c[1]=a[0]*b[1]+a[1]*b[0]$

$c[2]=a[0]*b[2]+a[1]*b[1]+a[2]*b[0]$
...

## 직관적 이해

길이 n짜리 수열 a, b를 특정한 규칙에 따라 변환시켜 수열 A, B로 바꾸었다고 생각해봅시다.
그런데 놀랍게도, 수열 A, B가 살고 있는 세계에서의 단순곱(pointwise product)이랑 수열 a, b가 살고 있는 세계에서의 convolution이 대응되는 관계를 갖고 있다는 사실이 밝혀졌습니다.

그 변환이 바로 이산 푸리에 변환(Discrete Fourier Transform)입니다.
(DFT를 빠르게 변환하는 방법이 FFT, Fast Fourier Transform 입니다.)


단순곱은 말 그대로 그냥 구구단 할 때 쓰던 그 곱셈을 의미합니다.
{1, 2, 3}이랑 {4, 5, 6}을 pointwise product 하면 {1*4, 2*5, 3*6} = {4, 10, 18}이 되겠죠.

길이 n짜리 수열 A, B의 pointwise product에는 O(N)만큼의 연산이 필요하겠네요.
그렇다면 수열을 이산 푸리에 변환하거나 이산 푸리에 역변환만 빠르게 할 수 있다면,
두 수열 a, b의 이산 합성곱을 O(n^2)보다도 빠르게 계산할 수 있겠네요!
[본문 링크](https://m.blog.naver.com/PostView.nhn?blogId=wjdalsdl1016&logNo=221109321310&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)

## 수학적 이해

합성곱(Convolution)연산은 함수를 입력받고 연산된 함수를 반환한다. 이는 입력된 함수의 특징을 추출할 수 있는 함수를 얻기 위해 사용되며, 원하는 특징을 추출할 수 있는 또 다른 함수가 합성곱 연산에 사용된다. 합성곱을 수행하는 방법 중 푸리에 변환은 가장 유명하다.

푸리에 변환은 오일러 공식(Euler's formula)을 통해 알 수 있는 `exp(x)` 함수의 복소평면에서의 특징을 이용한다. 이런 특징이란, `exp(x)`함수는 복소평면에서 원의 형태를 가진다는 것이다. 즉, `exp(xi) = cosx + isinx`라는 형태에서 exp함수를 주기 함수로 이용할 수 있다.

결국 푸리에 변환은 이러한 주기적 특성을 이용하여 주어진 함수의 주파수 성분을 분해한다. 이산 합성곱의 상황에서는 이와 다른 방향으로 주기성을 이용한다. 주의할 점은, 이산 합성곱의 상황에서는 DFT 자체가 원래 목적의 합성곱을 수행하지는 않는다는 것이다. 물론 DFT가 합성곱을 수행하기는 하지만, 원래 목적의 합성곱은 DFT이 이루어지고 나서 이루어진다. 이는 아래 내용을 통해 이해할 수 있을 것이다.


이산 합성곱은 함수가 주어졌을 때, 적분 대신 합을 하는 과정으로 생각할 수 있다. 특히, 컴퓨터 과학에서 사용하는 형태는 다항함수에 대한 이산 합성곱이다. 이런 경우, `matrix`로 생각할 수 있다. 모든 다항함수는 선형 시스템(Linear system)으로 표현할 수 있기 때문이다. 대표적인 예가 이미지를 처리하는 인공신경망인 CNN에서 사용하는 kernel을 이용한 Convolution연산일 것이다. 즉, vector나 matrix와 같은 이산적 데이터가 주어지면 다른 어떤 vector 또는 matrix에 대해 함성곱을 수행한 vector나 matrix를 반환하는 것으로 생각할 수 있다.

일반적인 선형 시스템에서는 다항 함수를 **'계수 표현'** 을 이용하여 표현한다. 다음과 같은 형태이다.

```
1 + x => (1, 1)
1 + x^2 => (1, 0, 1)
x + 4x^3 => (0, 1, 0, 4)
```

하나의 계수 표현은 하나의 다항함수와 대응됨은 자명하다.

계수 표현이 아닌 방법으로 다항함수를 표현할 수 있을까? 다음과 같은 표현을 생각해 보자.

`{(x1, y1), (x2, y2), (x3, y3), ..., (xn, yn)}`

이때, `yi = f(xi)`이다. xi와 yi를 이용하여 `XA = Y`와 같은 선형식을 만들 수 있는데, X는 xi값들로 **만들어진** 행렬이고 A는 다항식의 계수 행렬, Y는 yi로 이루어진 행렬이다. X는 xi값들로 만들어진 행렬로 xi의 제곱수 형태의 수들을 가지고 있는데, 선형 시스템의 i번째 row는 `f(xi) = yi`인 다항식을 표현하도록 구성되어 있다고 생각하면 쉽게 알 수 있을 것이다. 이러한 상황에서 X의 역행렬이 존재하면 A를 유일하게 표현할 수 있고, 이는 위와 같은 표현을 이용하여 다항함수 하나를 표현할 수 있다는 것이다. 이는 반데몬드(Vandermonde)행렬을 이용하여 증명될 수 있다. 단, 모든 xi는 서로 다른 값을 가져야 한다.

반데몬드 행렬을 이용한 증명을 통해 위와 같은 표기법을 통해 다항함수 하나를 표현할 수 있음이 보장됨을 알았다. 이러한 표현을 **'점값 표현'** 이라 한다. Lagrange형을 이용하여 점값 표현에서 다항함수를 구할 수 있고, 이는 점값 표현을 계수 표현으로 변환할 수 있음을 뜻한다.

이제 본 주제인 합성곱의 상황을 생각해 보자. 두 다항함수 A, B가 주어졌을 때, A와 B를 합성곱한 C를 구하는 상황은 다음과 같이 계수 표현으로 표현할 수 있다.

`A의 계수 벡터 a = (a1, a2, a3, ..., an)와 B의 계수 벡터 b = (b1, b2, b3, ..., bn)를 합성곱 하여 C의 계수 벡터 c = (c1, c2, c3, ..., cn)을 구하라`

계수 표현에서는 c를 구하기 위해 a와 b를 `O(N^2)`으로 구해야 한다. 하지만, 동일한 과정을 점값 표현으로 표현해 보자.

`A의 점값 벡터 a = (y1, y2, y3, ..., yn)와 B의 점값 벡터 b = (y1', y2', y3', ..., yn')를 합성곱 하여 c의 점값 벡터 c = (y1y1', y2y2', y3y3', ..., ynyn')을 구하라.`

c의 표현으로 부터 점값 표현의 상태에서는 c를 구하기 위해 `O(N)`이면 충분하다는 사실을 발견할 수 있다.

하지만, 여전히 문제는 계수 표현에서 점값 표현으로 변환하는 과정에서 `O(N^2)`이 필요하다는 것이다. 이런 변환을 `O(N^2)`미만으로 줄일 수 있다면 점값 표현을 이용하여 더 빠르게 이산 합성곱을 수행할 수 있을 것이다.

이제 변환 과정을 생각해 보자. 계수 표현에서 점값 표현으로 변환하는 과정 또한 합성곱으로 생각할 수 있다. 합성곱에 사용되는 x값은 서로 다르다는 조건만 만족하면 되므로, 푸리에 변환에 사용되는 exp값을 이용할 수 있다. 여기서 이산 푸리에 변환 DFT이 등장한다.

FFT는 exp값이 복소평면에서 주기성을 가진다는 것에 초점을 맞추어, 동일한 주기를 가지는 두 개의 다항 함수로 바꾸는 과정을 반복한다. 주어진 다항함수를 2개로 나누어 각각 연산하고 다시 합치는 과정을 반복하므로써 `O(NlogN)`만에 작업을 완료한다.

## Cooley-Tukey 알고리즘 (NLogN)

이 알고리즘은 분할정복의 아이디어를 사용한다.

수열 a를 짝수항, 홀수항을 나누어 계산하면 `길이가 
n인 수열의 이산 푸리에 변환` 문제를 `길이가 n/2인 수열 2개의 이산 푸리에 변환`으로 나누어서 해결할 수 있다.

자세한 수식은 [본문 링크](https://m.blog.naver.com/PostView.nhn?blogId=wjdalsdl1016&logNo=221109321310&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F) 참고

## 구현

일반적인 분할정복 방식과 다르게 짝수항, 홀수항으로 수열을 분할시켜야한다. 인덱스를 2진수로 표현한 후 좌우로 뒤집은 2진수에 해당하는 인덱스와 자리를 바꿔놓는 전처리작업을 해놓으면 순차적으로 절반씩 나누어 해결할 수 있다.

비재귀방식으로 분할정복을 구현하면 더 빠르게 동작한다.
