# Suffix Array

suffix를 모두 구한 뒤, 정렬한 배열을 다음과 같이 나타낸 것.

`SA[i] = i번째로 정렬된 suffix의 시작 인덱스`

## Nlog^2(N) 알고리즘
대상 문자열을 `str`, suffix array를 `SA`, suffix인 `SA[i]`의 우선순위를 결정하는 그룹번호를 `G[SA[i]]` 라 하자.

`SA[i] = i번째 suffix의 시작 index`

`G[i] = i번째 index의 우선순위 그룹 (단, t = 1일때 예외인 경우 방지: G[str.size()] = -1)`

`t = 1`부터 시작하여 각 suffix에서 길이 t만큼의 prefix를 비교해 `SA`를 정렬한다.

이때, `a = SA[i], b = SA[j]`를 정렬할 때, `G[a]`, `G[b]`를 비교하여 더 우선순위가 높은(= 값이 더 작은) 값이 앞에 온다. `G`값이 같을 경우가 문제인데, 이때에는 다음 문자열을 비교한 값 `G[a + t]`, `G[b + t]`를 비교한다.

정렬된 `SA`에 대해 다음 그룹 우선순위 `G`를 구하기 위해 `tG`를 만들고, `SA`을 탐색하며 `tG`에 오름차순으로 그룹번호가 매겨지도록 한다. 그룹번호를 0번 부터 매긴다면, `tG[0] = 0`으로 두고 `SA[i]`, `SA[i + 1]`의 현재 `t`에 대한 `G`값이 다르다면 1을 추가하고 아니라면 같은 경우일때 이므로 `tG[i + 1] = tG[i]` 로 한다.

다음 턴의 `G`값이 `SA`정렬된 순서로 `tG`에 기록되어 있으므로 `G[SA[i]] = tG[i]`로 `G`를 갱신해준다.

이때, `tG[str.size() - 1] == str.size() - 1`를 만족하면 그룹 번호가 0부터 모두 매겨진 상태이므로 `SA`가 완성된 상태임을 알 수 있다.

완성된 상태라면 `break`해주고 아니라면 `t <<= 1` 해준다. (t <= str.size())
